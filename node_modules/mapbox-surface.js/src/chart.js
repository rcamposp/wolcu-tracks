var d3 = require('../lib/d3_custom');
var utility = require('./utility');

var SurfaceControl = L.Control.extend({
    includes: L.Mixin.Events,

    options: {
        collapsed: true,
        position: 'topright',
        autoZIndex: true
    },

    initialize: function(options, data) {
        options.data = data;
        L.setOptions(this, options);
    },

    onAdd: function(map) {
        this._map = map;
        var classNames = 'leaflet-surface-chart leaflet-bar';
        var container = this._container = L.DomUtil.create('div', classNames);
        d3.select(container).attr('id', 'chart-container');
        this._removeChart();
        this._makeChart();
        return container;
    },

    _makeChart: function() {
        var surface = this;
        var options = this.options;
        var data = utility.formatValuesForChart(options.data.results, options);

        if (data.length <= 1) throw new Error('Too few points to create a chart');
        if (data.type === 'FeatureCollection') throw new Error('Turn option `geojson` to false to use chart');

        if(!options.yAxis.data) throw new Error('A yAxis data field is required');
        for (var i = 0; i < data.length; i++) {
            if (typeof data[i][options.yAxis.data] === 'string') {
                throw new Error('L.mapbox.surface.chart only works with integers. "' + options.yAxis.data + '" is a string.');
            }
        }

        options.margin = options.margin || [25, 20, 25, 60];
        options.height = options.height || 100;
        options.width = options.width || 350;
        options.xAxis = options.xAxis || {};
        options.yAxis = options.yAxis || {};
        options.xAxis.numberOfTicks = options.xAxis.numberOfTicks || 5;
        options.yAxis.numberOfTicks = options.yAxis.numberOfTicks || 4;
        options.xAxis.units = options.xAxis.units || 'km';
        options.yAxis.units = options.yAxis.units || '';
        options.xAxis.label = options.xAxis.label || null;
        options.yAxis.label = options.yAxis.label || null;
        options.xAxis.data = options.xAxis.data || 'distance';
        options.yAxis.data = options.yAxis.data;

        var domainX = d3.extent(data, function(datum) {
            return datum[options.xAxis.data];
        });
        var domainY = d3.extent(data, function(datum) {
            return datum[options.yAxis.data];
        });

        var rangeX = [0, options.width],
            rangeY = [options.height, 0];

        var scaleX = d3.scale.linear()
            .domain(domainX)
            .range(rangeX);
        var scaleY = d3.scale.linear()
            .domain(domainY)
            .range(rangeY);

        var xAxis = d3.svg.axis()
            .scale(scaleX)
            .orient('bottom')
            .outerTickSize(0)
            .ticks(options.xAxis.numberOfTicks)
            .tickFormat(function(d) { return d + ' ' + options.xAxis.units; });

        var yAxis = d3.svg.axis()
            .scale(scaleY)
            .outerTickSize(0)
            .orient('left')
            .ticks(options.yAxis.numberOfTicks)
            .tickFormat(function(d) { return d + ' ' + options.yAxis.units; });

        var line = d3.svg.line()
            .interpolate('monotone')
            .x(function(datum) {
                return scaleX(datum[options.xAxis.data]);
            })
            .y(function(datum) {
                return scaleY(datum[options.yAxis.data]);
            });

        var area = d3.svg.area()
            .interpolate('monotone')
            .x(function(d) {
                return scaleX(d[options.xAxis.data]);
            })
            .y0(options.height)
            .y1(function(d) {
                return scaleY(d[options.yAxis.data]);
            });

        var svg = d3.select(surface._container)
            .append('div')
            .attr('id', 'chart')
            .append('svg')
            .attr('width', options.width + options.margin[3] + options.margin[1])
            .attr('height', options.height + options.margin[0] + options.margin[2])
            .append('g')
            .attr('transform', 'translate(' + options.margin[3] + ',' + options.margin[0] + ')');

        var extent = d3.extent(data, function(d) { return d[options.yAxis.data]; });
        extent[0] = extent[0] - (extent[0] * 0.05);

        scaleX.domain([data[0][options.xAxis.data], data[data.length - 1][options.xAxis.data]]);
        scaleY.domain(extent);

        if (options.chartType === 'area') {
            svg.append('path')
                .datum(data)
                .attr('class', 'area')
                .attr('d', area);
            svg.append('path')
                .datum(data)
                .attr('class', 'line')
                .attr('d', line);
        } else {
            svg.append('path')
                .datum(data)
                .attr('class', 'line')
                .attr('d', line);
        }

        svg.append('g')
            .attr('class', 'x axis')
            .attr('transform', 'translate(0,' + options.height + ')')
            .call(xAxis)
            .append('text')
            .style('text-anchor', 'end')
            .attr('x', options.width)
            .attr('y', -7)
            .text(options.xAxis.label);

        svg.append('g')
            .attr('class', 'y axis')
            .call(yAxis)
            .append('text')
            .attr('y', -15)
            .attr('x', -5)
            .text(options.yAxis.label);


        var hover = svg
            .append('g');

        hover.append('text')
            .attr('x', -15)
            .attr('class', 'hover-text')
            .attr('dy', -5);

        hover.append('line')
            .attr({
                'x1': 0,
                'y1': 0,
                'x2': 0,
                'y2': options.height
            }).attr('class', 'hover-line');

        var bisect = d3.bisector(function(datum) {
            return datum[options.xAxis.data];
        }).right;

        svg.append('rect')
            .attr('class', 'overlay')
            .attr('width', options.width)
            .attr('height', options.height)
            .on('mouseover', function() {
                hover.style('display', 'inherit');
            })
            .on('mouseout', function() {
                hover.style('display', 'none');
                surface._resetHoverMarker();
            })
            .on('mousemove', mousemove);

        function mousemove() {
            var mouse = d3.mouse(this),
                mouseX = scaleX.invert(mouse[0]),
                index = bisect(data, mouseX),
                startDatum = data[index - 1],
                endDatum = data[index],
                interpolateValue = d3.scale.linear()
                    .range([0, 1])
                    .domain([startDatum[options.xAxis.data], endDatum[options.xAxis.data]]);

            var bias = interpolateValue(mouseX);
            var intData = utility.lerp(startDatum, endDatum, bias, options.yAxis.data);

            hover.attr('transform', 'translate(' + mouse[0] + ',0)');
            hover.select('text')
                .text(intData.value.toFixed(0) + ' ' + options.yAxis.units);

            if(surface._markerLayer){
                surface._markerLayer.setLatLng([intData.lat, intData.lng]);
            } else {
                surface._addHoverMarker(intData.lat, intData.lng);
            }
        }

        this._svg = svg;
    },

    _addHoverMarker: function(lat, lng) {
        var markerLayer = L.circleMarker([lat, lng], {
            color: '#fff',
            width: '2px',
            opacity: 1,
            fillColor: '#3887be',
            fillOpacity: 1
        })
            .setRadius(8);

        this._map.addLayer(markerLayer);
        this._markerLayer = markerLayer;
    },

    _resetHoverMarker: function() {
        this._map.removeLayer(this._markerLayer);
        delete this._markerLayer;
    },

    _removeChart: function(container) {
        d3.select('.leaflet-surface-chart #chart').remove();
    }

});

module.exports = function(_, options) {
    return new SurfaceControl(_, options);
};
