/* global L */
var d3 = require('../lib/d3_custom');

module.exports = function(options) {

    var surface = {};
    if (options) surface.options = options;

    surface.getData = function(options, latlngs, callback) {
        if (surface.options && options instanceof Array) {
            callback = latlngs;
            latlngs = options;
            options = surface.options;
        }

        if (!options.mapid) return callback('Missing mapid');
        if (!options.layer) return callback('Missing layer');
        if (!options.fields) return callback('Missing fields');

        options.access_token = L.mapbox.accessToken;
        var url = 'https://api.tiles.mapbox.com/v4/surface/' + options.mapid + '.json?';
        if (latlngs.lat) {
            options.points = latlngs.lng + ',' + latlngs.lat;
        } else if (latlngs.length === 2) {
            options.points = latlngs[1] + ',' + latlngs[0];
        } else if (latlngs.length === 1) {
            options.points = latlngs[0][1] + ',' + latlngs[0][0];
        } else {
            options.points = latlngs.map(function(l) {
                return l.reverse().join(',');
            }).join(';');
        }

        this.getHTTP(url, options, function(error, response) {
            if (error) return callback(error, null);

            var totalDistance = 0;
            if (!options.geojson) {
                for (var i = 0; i < response.results.length; i++) {
                    if (i === 0) {
                        totalDistance += surface._calculateDistance(response.results[0].latlng.lat, response.results[0].latlng.lng, response.results[0].latlng.lat, response.results[0].latlng.lng);
                        response.results[i].distance = parseFloat(totalDistance.toFixed(3));
                    } else if (i < response.results.length - 1) {
                        totalDistance += surface._calculateDistance(response.results[i].latlng.lat, response.results[i].latlng.lng, response.results[i + 1].latlng.lat, response.results[i + 1].latlng.lng);
                        response.results[i].distance = parseFloat(totalDistance.toFixed(3));
                    } else {
                        totalDistance += surface._calculateDistance(response.results[response.results.length - 1].latlng.lat, response.results[response.results.length - 1].latlng.lng, response.results[response.results.length - 2].latlng.lat, response.results[response.results.length - 2].latlng.lng);
                        response.results[i].distance = parseFloat(totalDistance.toFixed(3));
                    }
                }
            }

            return callback(error, response);
        });
    };

    surface.getInfo = function(mapid, callback) {
        var url = 'https://a.tiles.mapbox.com/v4/' + mapid + '.json?access_token=' + L.mapbox.accessToken;

        this.getHTTP(url, null, function(err, response) {
            if (err) return callback(err, null);

            // Rename to stay consistent with the API
            for (var i = 0; i < response.vector_layers.length; i++) {
                response.vector_layers[i].layer = response.vector_layers[i].id;
                delete response.vector_layers[i].id;
            }
            return callback(null, response.vector_layers);
        });
    };

    surface.calculateBetween = function(options, toPoint, fromPoint, intervalCount, callback) {
        var queryPoints = [],
            latDifference = toPoint[0] - fromPoint[0],
            lngDifference = toPoint[1] - fromPoint[1],
            latDelta = latDifference / intervalCount,
            lngDelta = lngDifference / intervalCount;
        for (var s = intervalCount - 1; s >= 0; s--) {
            var intervalLat = (s * latDelta) + fromPoint[0];
            var intervalLng = (s * lngDelta) + fromPoint[1];
            queryPoints.push([intervalLat, intervalLng]);
        }

        if (queryPoints.length > 300) return callback('Query is too long, max number of points is 300.');

        this.getData(options, queryPoints, function(err, response) {
            return callback(null, response);
        });

    };

    surface.getHTTP = function(url, params, callback) {
        d3.json(url + this._queryString(params), function(err, resp) {
            if (err) return callback(err.responseText, null);
            return callback(null, resp);
        }, true);
    };

    surface._calculateDistance = function(lat1, lng1, lat2, lng2) {
        var surface = this;
        var RKm = 6378.1; // Radius of the earth in km
        var dLat = surface._calculateDeg2Rad(lat2 - lat1); // deg2rad below
        var dLon = surface._calculateDeg2Rad(lng2 - lng1);
        var a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(surface._calculateDeg2Rad(lat1)) * Math.cos(surface._calculateDeg2Rad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = RKm * c; // Distance in km
        return d;
    };

    surface._calculateDeg2Rad = function(deg) {
        return deg * (Math.PI / 180);
    };

    surface._queryString = function(object) {
        var str = [];
        for (var p in object)
            if (object.hasOwnProperty(p)) {
                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(object[p]));
            }
        return str.join('&');
    };

    return surface;

};
